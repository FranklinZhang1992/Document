Openstack Swift
OpenStack Swift 是一个对象存储示例，它在概念上与 Amazon Simple Storage Service 类似。
与之相反，OpenStack Cinder 表示块存储，类似于 Amazon Elastic Block Store。

块存储 (Cinder)

Cinder 是 OpenStack Block Storage 的项目名称；它为来宾虚拟机 (VM) 提供了持久块存储。对于可扩展的文件系统、最大性能、与企业存储服务的集成以及需要访问原生块级存储的应用程序而言，块存储通常是必需的。

系统可以暴露并连接设备，随后管理服务器的创建、附加到服务器和从服务器分离。应用程序编程接口 (API) 也有助于加强快照管理，这种管理可以备份大量块存储。

对象存储 (Swift)
Swift 是两种产品中较为成熟的一个：自 OpenStack 成立以来一直是一个核心项目。Swift 的功能类似于一个分布式、可访问 API 的存储平台，可直接将它集成到应用程序中，或者用于存储 VM 镜像、备份和归档以及较小的文件，例如照片和电子邮件消息。
Object Store 有两个主要的概念：对象和容器。
对象就是主要存储实体。对象中包括与 OpenStack Object Storage 系统中存储的文件相关的内容和所有可选元数据。数据保存为未压缩、未加密的格式，包含对象名称、对象的容器以及键值对形式的所有元数据。对象分布在整个数据中心的多个磁盘中，Swift 可以借此确保数据的复制和完整性。分布式操作可以利用低成本的商用硬件，同时增强可扩展性、冗余性和持久性。
容器类似于 Windows® 文件夹，容器是用于存储一组文件的一个存储室。容器无法被嵌套，但一个租户可以供创建无限数量的容器。对象必须存储在容器中，所以您必须至少拥有一个容器来使用对象存储
与传统的文件服务器不同，Swift是横跨多个系统进行分布的。它会自动存储每个对象的冗余副本，从而最大程度地提高可用性和可扩展性。对象版本控制提供了防止数据意外丢失或覆盖的额外保护。
Swift 架构

Swift 架构包含三个组件：服务器、流程和环。

服务器

Swift 架构是分布式的，可防止所有单点故障和进行水平扩展。它包括以下四种服务器：
代理服务器
对象服务器
容器服务器
帐户服务器

代理服务器为 OpenStack Object Storage 架构的其余部分提供一个统一的界面。它接收创建容器、上传文件或修改元数据的请求，还可以提供容器清单或展示存储的文件。当收到请求时，代理服务器会确定帐户、容器或对象在环中的位置，并将请求转发至相关的服务器。

对象服务器是一种简单的服务器，可以上传、修改和检索存储在它所管理的设备上的对象（通常为文件）。对象被存储在本地文件系统中，使用了扩展的属性保存所有的元数据。路径基于对象名称的散列和时间戳。

容器服务器实质上是对象的一个目录。它处理特定容器的对象的分配，并根据请求来提供容器清单。可以跨集群复制该清单，以提供冗余。
帐户服务器通过使用对象存储服务来管理帐户。它的操作类似于在内部提供了清单的容器服器，在这种情况下，将会枚举分配到给定帐户的容器。
流程

有几种预定的内部管理流程可以管理数据存储，包括复制服务、审计程序（auditor）和更新程序（updater）。

复制服务是至关重要的流程：确保整个集群的一致性和可用性。由于对象存储的一个主要吸引点是其分布式存储，所以 OpenStack 必须在瞬态错误条件下确保获得一致的状态，例如断电或组件故障。复制服务通过定期对比本地数据与远程副本并确保所有副本都包含最新版本来做到这一点。

为了最大程度地减少进行对比所需的网络流量的数量，该服务创建了每个分区分段的一个散列（hash），并比较这些列表。容器和帐户复制也可以使用散列，但通过高水位标记（high-water mark）对这些散列进行了补充。实际的更新被推送，通常使用 rsync 来复制对象、容器和帐户。

在删除对象、容器或帐户时，复制器（replicator）还会执行垃圾收集来实施一致的数据删除。在删除时，系统会使用一个墓碑图片来标记最新版本，这是一个告诉复制器可以从所有重复的节点中删除对象、容器或帐户的信号。

即使是最好的复制设计，也只在拥有实现该复制的组件时有效，不过，无论是硬件故障还是软件故障，抑或只是因为产品能力不足，生产环境都必须能够重现这些故障。在 Swift 中，该操作是由更新程序和审计程序来完成的。

更新程序负责在系统面临故障时确保系统的完整性。当复制服务遇到一个问题，并且无法更新容器或帐户时，就会出现一段时间的不一致，在此其间，对象虽然存在于存储中，但并未列出在所有容器或帐户服务器上。在这种情况下，系统会在本地文件系统上对更新进行排队，并有一个更新程序会定期重试更新。

审计程序对这种不一致提供额外级别的保护。它们定期扫描本地存储库，验证帐户、容器和对象的完整性。在确认任何损坏时，审计程序会隔离该元素，并使用来自另一个复制物的副本替换它。如果发现了无法协调的不一致性（例如，对象不属于任何容器），审计程序就会将该错误记录在一个日志文件中。

环

用户和其他 OpenStack 项目会根据逻辑名称来引用存储实体，但最终，所有请求，无论是用于读取还是用于写入，都必须映射到某个物理位置。为了完成这一操作，代理服务器和后台流程（包括复制服务）都必须能够将逻辑名称映射到物理位置。这种映射就称为一个环（ring）。帐户、容器和对象都配有单独的环。环根据设备、分区、副本和专区来描述这一映射。

在此上下文中，术语分区 指的是环中所存储内容的逻辑子集。建议为每个参与设备分配 100 个分区。分区均匀地分布在分配给 OpenStack Object Storage 的所有设备上。如果集群使用了不同规格的驱动，那么有可能会分配权重，以便平衡各个设备上的分区的分布。

默认情况下，每个分区可被复制三次。有可能会使用一个较大的数字来优化可用性，但这显然会增加存储消耗。环还会指定在故障场景中使用哪些设备来接管工作负载，以及在向集群添加设备或从中删除设备时如何重新分配分区。

环映射的最后一个元素是专区，用于启用数据亲和性和反亲和性，一个专区可以表示一个存储设备、一个物理服务器或者一个位置，例如机架、通道或数据中心，专区是用户可用来满足其需求的一个逻辑概念，但通常反映的是物理元素，例如位置、电源和网络连接。

Cinder 架构
与其他 OpenStack 项目类似，Cinder 的功能通过 API 暴露给仪表板和命令行。它能够通过具有具象状态传输 (Representational State Transfer, REST) 的 HTTP API 来访问对象存储，并使用一个名为 Auth Manager 的 Python 类将身份验证纳入 OpenStack Keystone。

API 解析所有传入的请求并将它们转发给消息队列，调度程序和卷服务器在该队列中执行实际的工作。在创建新的卷时，调度程序将会决定哪台主机应对该卷负责。默认情况下，它会选择拥有最多可用空间的节点。

卷管理程序管理着可动态附加的块存储设备，这些设备也被称为卷。它们可用作虚拟实例的启动设备，或作为辅助存储进行添加。Cinder 还为快照（卷的只读副本）提供了一种设备。然后可以使用这些快照来创建新的卷，以供读写使用。

卷通常通过 iSCSI 附加到计算节点。块存储也需要某种形式的后端存储，在默认情况下，该后端存储是本地卷组上的逻辑卷管理，但可以通过驱动程序将它扩展到外部存储阵列或设备。

